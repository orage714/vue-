{"remainingRequest":"C:\\Users\\95764\\Desktop\\框架练习\\VUE\\jiaosjoujia\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\95764\\Desktop\\框架练习\\VUE\\jiaosjoujia\\src\\App.vue?vue&type=custom&index=0&blockType=any","dependencies":[{"path":"C:\\Users\\95764\\Desktop\\框架练习\\VUE\\jiaosjoujia\\src\\App.vue","mtime":1538020203284},{"path":"C:\\Users\\95764\\Desktop\\框架练习\\VUE\\jiaosjoujia\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1538013468417},{"path":"C:\\Users\\95764\\Desktop\\框架练习\\VUE\\jiaosjoujia\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;\r\n  ready: boolean;\r\n  readyCbs: Array<Function>;\r\n  options: RouterOptions;\r\n  mode: string;\r\n  history: HashHistory | HTML5History | AbstractHistory;\r\n  matcher: Matcher;\r\n  fallback: boolean;\r\n  beforeHooks: Array<?NavigationGuard>;\r\n  resolveHooks: Array<?NavigationGuard>;\r\n  afterHooks: Array<?AfterNavigationHook>;\r\n\r\n  constructor (options: RouterOptions = {}) {\r\n    this.app = null\r\n    this.apps = []\r\n    this.options = options\r\n    this.beforeHooks = []\r\n    this.resolveHooks = []\r\n    this.afterHooks = []\r\n    this.matcher = createMatcher(options.routes || [], this)\r\n\r\n    let mode = options.mode || 'hash'\r\n    this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false\r\n    if (this.fallback) {\r\n      mode = 'hash'\r\n    }\r\n    if (!inBrowser) {\r\n      mode = 'abstract'\r\n    }\r\n    this.mode = mode\r\n\r\n    switch (mode) {\r\n      case 'history':\r\n        this.history = new HTML5History(this, options.base)\r\n        break\r\n      case 'hash':\r\n        this.history = new HashHistory(this, options.base, this.fallback)\r\n        break\r\n      case 'abstract':\r\n        this.history = new AbstractHistory(this, options.base)\r\n        break\r\n      default:\r\n        if (process.env.NODE_ENV !== 'production') {\r\n          assert(false, `invalid mode: ${mode}`)\r\n        }\r\n    }\r\n  }\r\n\r\n  match (\r\n    raw: RawLocation,\r\n    current?: Route,\r\n    redirectedFrom?: Location\r\n  ): Route {\r\n    return this.matcher.match(raw, current, redirectedFrom)\r\n  }\r\n\r\n  get currentRoute (): ?Route {\r\n    return this.history && this.history.current\r\n  }\r\n\r\n  init (app: any /* Vue component instance */) {\r\n    process.env.NODE_ENV !== 'production' && assert(\r\n      install.installed,\r\n      `not installed. Make sure to call \\`Vue.use(VueRouter)\\` ` +\r\n      `before creating root instance.`\r\n    )\r\n\r\n    this.apps.push(app)\r\n\r\n    // main app already initialized.\r\n    if (this.app) {\r\n      return\r\n    }\r\n\r\n    this.app = app\r\n\r\n    const history = this.history\r\n\r\n    if (history instanceof HTML5History) {\r\n      history.transitionTo(history.getCurrentLocation())\r\n    } else if (history instanceof HashHistory) {\r\n      const setupHashListener = () => {\r\n        history.setupListeners()\r\n      }\r\n      history.transitionTo(\r\n        history.getCurrentLocation(),\r\n        setupHashListener,\r\n        setupHashListener\r\n      )\r\n    }\r\n\r\n    history.listen(route => {\r\n      this.apps.forEach((app) => {\r\n        app._route = route\r\n      })\r\n    })\r\n  }\r\n\r\n  beforeEach (fn: Function): Function {\r\n    return registerHook(this.beforeHooks, fn)\r\n  }\r\n\r\n  beforeResolve (fn: Function): Function {\r\n    return registerHook(this.resolveHooks, fn)\r\n  }\r\n\r\n  afterEach (fn: Function): Function {\r\n    return registerHook(this.afterHooks, fn)\r\n  }\r\n\r\n  onReady (cb: Function, errorCb?: Function) {\r\n    this.history.onReady(cb, errorCb)\r\n  }\r\n\r\n  onError (errorCb: Function) {\r\n    this.history.onError(errorCb)\r\n  }\r\n\r\n  push (location: RawLocation, onComplete?: Function, onAbort?: Function) {\r\n    this.history.push(location, onComplete, onAbort)\r\n  }\r\n\r\n  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {\r\n    this.history.replace(location, onComplete, onAbort)\r\n  }\r\n\r\n  go (n: number) {\r\n    this.history.go(n)\r\n  }\r\n\r\n  back () {\r\n    this.go(-1)\r\n  }\r\n\r\n  forward () {\r\n    this.go(1)\r\n  }\r\n\r\n  getMatchedComponents (to?: RawLocation | Route): Array<any> {\r\n    const route: any = to\r\n      ? to.matched\r\n        ? to\r\n        : this.resolve(to).route\r\n      : this.currentRoute\r\n    if (!route) {\r\n      return []\r\n    }\r\n    return [].concat.apply([], route.matched.map(m => {\r\n      return Object.keys(m.components).map(key => {\r\n        return m.components[key]\r\n      })\r\n    }))\r\n  }\r\n\r\n  resolve (\r\n    to: RawLocation,\r\n    current?: Route,\r\n    append?: boolean\r\n  ): {\r\n    location: Location,\r\n    route: Route,\r\n    href: string,\r\n    // for backwards compat\r\n    normalizedTo: Location,\r\n    resolved: Route\r\n  } {\r\n    const location = normalizeLocation(\r\n      to,\r\n      current || this.history.current,\r\n      append,\r\n      this\r\n    )\r\n    const route = this.match(location, current)\r\n    const fullPath = route.redirectedFrom || route.fullPath\r\n    const base = this.history.base\r\n    const href = createHref(base, fullPath, this.mode)\r\n    return {\r\n      location,\r\n      route,\r\n      href,\r\n      // for backwards compat\r\n      normalizedTo: location,\r\n      resolved: route\r\n    }\r\n  }\r\n\r\n  addRoutes (routes: Array<RouteConfig>) {\r\n    this.matcher.addRoutes(routes)\r\n    if (this.history.current !== START) {\r\n      this.history.transitionTo(this.history.getCurrentLocation())\r\n    }\r\n  }\r\n}\r\n\r\nfunction registerHook (list: Array<any>",null]}